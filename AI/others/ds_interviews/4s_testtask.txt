# task 1

WITH pc_min_ram AS (
	SELECT MIN(ram) as ram FROM pc
), pc_min_ram_max_speed AS (
	SELECT MAX(speed) speed
	FROM pc
	WHERE ram = ( SELECT ram FROM pc_min_ram )
), printer_makers AS (
	SELECT maker
	FROM product
	WHERE type = 'Printer'
)

SELECT DISTINCT maker
FROM Product
WHERE model IN (
	SELECT model
	FROM pc
	WHERE ram = (SELECT ram FROM pc_min_ram)
	AND speed = (SELECT speed FROM pc_min_ram_max_speed)
)
AND maker IN (
	SELECT maker
	FROM printer_makers
);

В этом решении выполняется 9 SELECT запросов, 5 из которых выполняются на таблицах в базе данных, 4 из которых выполняются на временных таблицах (pc_min_ram, pc_min_ram_max_speed, printer_makers).
Если цена выполнения SELECT запросов на временные таблицы высока (например, если существует много компьютеров с минимальным значением ram), то в этом случае некоторые из временных таблиц можно вставить в сам запрос. Например,
"""
... AND maker IN (SELECT maker FROM printer_makers );  -- 2 запроса
"""
станет
"""
... AND maker IN (SELECT maker FROM product WHERE type='Printer');  -- 1 запрос
"""


# task 2
DATETIME и TIMESTAMP используются для хранения даты и времени событий.
Основные функции, которые работают с датами и временем (datediff, days, day_of_week итд) работают с обоими типами.

Основные отличия:

1. Границы возможных значений - TIMESTAMP - можно создавать даты только с 1970-01-01, DATETIME - даты намного ранее 1970 года.
Дату каких-то событий (например, день рождения) лучше хранить в DATETIME.

2. Временные зоны - значение типа TIMESTAMP при смене временной зоны на исполняющей машине изменит значение даты, DATETIME - нет.
Это происходит потому, что при добавлении значения типа TIMESTAMP дата конвертируется в UTC формат.
При чтении TIMESTAMP значения дата конвертируется в временную зону, которая выставлена на исполняющей машине.

Если данные в таблице обновляются в нескольких временных зонах - можно использовать DATETIME
Если временные зоны не так важны - можно использовать TIMESTAMP

3. Размер - TIMESTAMP использует меньше памяти чем DATETIME.
С увелечением количества данных в таблице эта разница не сильно заметна.


# task 3
SELECT
        surveyinstanceid, 
        project, 
        datedue, 
        login, 
        securityobjectuserid, 
        workflowstepid
FROM
        [bigquery-project:bigquery_tablename]
WHERE
        datedue IS NOT NULL
AND
        DATEDIFF( datedue, NOW() ) > 3


# task 4
- Основная суть метода наименьших квадратов - нахождение линейной модели, которая наилучшим образом объясняет существующие данные, минимизируя расстояние между реальными и предпологаемыми значениями.

- Не менее скольких наблюдений необходимо для рассчета параметров парной линейной регрессии?
Не менее двух для рассчета коэффициентов k и b в уравнении y-kx=b.
Если сделать 0 или 1 наблюдение, то существует бесконечное множество параметров модели парной линейной регрессии.
Для адекватного статистического анализа надо брать то количество наблюдений, которое удовлетворяет нашим значениям статистической значимости/мощности.

- Какой коэффициент оценивает качество модели из относительных отклонений по каждому наблюдению?
Метрика r2 (коэффициент детерминации)
r2->1 - сумма квадратов ошибок небольшая, хорошая модель.
r2->0 - сумма квадратов ошибок близкая к ошибкам, если бы мы использовали усредненную модель (y=b), плохая модель.

- Для чего используется линейная регрессия?
Для нахождения зависимости параметров от целевой функции, где нулевая гипотеза подразумевает что параметры (features) модели линейны.
После нахождения зависимости можем с некоторой точностью предсказывать значения на новых, ранее неизвестных данных.
Также можем использовать результаты работы модели для интерпретации "значимости" параметров - по значениям взвешенной суммы параметров можно понять какие параметры важнее других.
